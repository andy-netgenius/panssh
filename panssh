#!/usr/bin/env bash

###############################################################################
# PanSSH - Pantheon interactive SSH session emulator
#
# Emulates an interactive ssh connection to a Pantheon site's application
# environment.
#
# Author: Andy Inman - ainman@netgenius.co.uk
# Copyright (c) 2025 Andrew Inman.
# Portions Copyright (c) 2025 Last Call Media.
#
# License: MIT
# SPDX-License-Identifier: MIT
###############################################################################

readonly PANSSH_VERSION="PanSSH 1.2.1"

# --- Configuration ---
readonly SSH_PORT="2222"

readonly SITES_FILE="$HOME/.panssh.sites"
readonly STORAGE_DIR="$HOME/.panssh"
readonly TEMP_DIR="/tmp/panssh-$$"
mkdir -p -m 700 "$STORAGE_DIR" "$TEMP_DIR"

readonly LOCAL_HOST=$(hostname -s)
readonly LOCAL_USER=$(whoami)
readonly REMOTE_HOME="/tmp/panssh-home.$LOCAL_USER.$LOCAL_HOST"
readonly REMOTE_ENV="HOME=\"$REMOTE_HOME\" XDG_CACHE_HOME=\"$REMOTE_HOME/.cache\" WP_CLI_CACHE_DIR=\"$REMOTE_HOME/.cache/wp-cli\""

readonly SSH_OPTIONS=" \
  -o ConnectTimeout=30 \
  -o ControlMaster=auto \
  -o ControlPath=$TEMP_DIR/ssh.socket \
  -o ControlPersist=5m \
  -o LogLevel=info \
  -o Port=$SSH_PORT \
  -o StrictHostKeyChecking=accept-new \
  -o UserKnownHostsFile=$STORAGE_DIR/known_hosts"

# Location of this script.
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load SITE_IDs from config ---
if [[ ! -f "$SITES_FILE" ]]; then
    echo -e "\n$PANSSH_VERSION" >&2
    echo -e "\nðŸŸ¡ Sites file not found at: $SITES_FILE" >&2
    echo -e "\nTo create it, run:" >&2
    [[ "$LANDO" == "ON" ]] && echo -e "  lando ssh" >&2
    echo -e "  terminus site:list --format=csv --fields=name,id > $SITES_FILE\n" >&2
    exit 1
fi

# List all built-in commands.
show_commands() {
    echo -e "\nBuilt-in commands:\n" >&2
    echo -e "  Show this command list:  .help" >&2
    echo -e "  View a file:  .view <filepath>" >&2
    echo -e "  Edit a file:  .edit <filepath>" >&2
    echo -e "  Copy directories/files:  .copy [local:]<source> [local:]<target>" >&2
    echo -e "  Run rsync:  .rsync [options] [local:]<source> [local:]<target>" >&2
    echo -e "  Toggle automatic directory listing:  .ls" >&2
    echo -e "\n  Short versions:  .vw .ed .cp .rs .ls\n" >&2
}

# Parse command-line, get site.env argument.
if [[ ! "$1" =~ ^([a-zA-Z0-9\-]+)\.([a-zA-Z0-9\-]+)$ ]]; then
    [[ "$0" == "./panssh" ]] && panssh="$0" || panssh="panssh"
    echo -e "\n$PANSSH_VERSION" >&2
    echo -e "\nUsage examples:\n" >&2
    echo -e "  $panssh site.env" >&2
    echo -e "  $panssh site.env \"commands\"" >&2
    echo -e "  $panssh site.env < script.sh" >&2
    echo -e "  echo \"commands\" | $panssh site.env" >&2
    show_commands
    echo -e "To create or update your available sites configuration, run:" >&2
    [[ "$LANDO" == "ON" ]] && echo -e "  lando ssh" >&2
    echo -e "  terminus site:list --format=csv --fields=name,id > $SITES_FILE\n" >&2

    exit 1
fi

# Set site and environment names, lookup site ID.
readonly SITE_NAME="${BASH_REMATCH[1]}"
readonly ENV_ID="${BASH_REMATCH[2]}"
readonly SITE_ID=$(grep -E "^$SITE_NAME," "$SITES_FILE" | cut -d',' -f2)

if [[ -z "$SITE_ID" ]]; then
    echo "âŒ Site '$SITE_NAME' not found in $SITES_FILE" >&2
    exit 1
fi

readonly USER="$ENV_ID.$SITE_ID"
readonly HOST="appserver.$ENV_ID.$SITE_ID.drush.in"

# --- SSH wrapper ---
ssh_exec() {
    local cmd=$(printf '%q' "$1")
    ssh $SSH_OPTIONS "$USER@$HOST" "echo $cmd | bash"
    # Don't add anything here without saving and returning correct status.
}

# --- SSH wrapper with syntax check, status and current directory tracking ---
ssh_exec_track() {
    local cwd_marker="PANSSH_status_cwd:"

    # Build command parts.
    local pre_cmd="$1"
    local cmd="$2"
    local clean_cmd="${cmd%;}"
    local post_cmd="echo \"$cwd_marker\$?|\$(pwd)\""

    # Run the command and print its output until we hit our marker.
    local line
    while IFS= read -r line && [[ "$line" != "$cwd_marker"* ]]; do
        echo "$line"
    done < <(
        # Run syntax check first, then full command if syntax is valid.
        ssh_exec "bash -n -c '$cmd' && bash -c '$pre_cmd; $clean_cmd; $post_cmd'"
    )

    # Extract status code and working directory from the final line.
    local status_cwd="${line#"$cwd_marker"}"

    # Check for failure - can happen due to syntax error (status 2), etc.
    if [[ -z "$status_cwd" ]]; then
        return 2
    fi

    # Set remote directory and return status code.
    REMOTE_CWD="${status_cwd#*|}"
    return "${status_cwd%%|*}"
}

# --- Close SSH connection and clean up ---
cleanup() {
    local status=$?

    if ssh -O check $SSH_OPTIONS "$USER@$HOST" 2>/dev/null; then
        ssh -O exit $SSH_OPTIONS "$USER@$HOST" 2>/dev/null
        echo -e "\nConnection to $SITE_NAME.$ENV_ID closed." >&2
    elif [[ -S "$TEMP_DIR/ssh.socket" ]]; then
        echo -e "\nConnection to $SITE_NAME.$ENV_ID was already closed." >&2
    fi

    history -a
    rm -r "$TEMP_DIR"
    exit $status
}
trap cleanup EXIT

# --- Execute commands from command-line or stdin ---
if [[ $# -gt 1 ]] || ! [ -t 0 ]; then
    if [[ $# -gt 1 ]]; then
        shift
        cmd="$*"
    else
        cmd=$(cat)
    fi
    ssh_exec "$REMOTE_ENV; $cmd"
    exit $?
fi

# --- File transfer between local and host ---
transfer_file() {
    # Standard scp fails under Lando, reason unknown.
    # Until resolved, we use rsync as a workaround.
    if [[ $LANDO != "ON" ]]; then
        scp -q $SSH_OPTIONS "$1" "$2"
    else
        rsync -qe "ssh $SSH_OPTIONS" "$1" "$2"
    fi
    return $?
}

# --- Launch local text editor ---
launch_editor() {
    local file="$1"
    shift
    local editor_args=("$@")

    if [[ -n "$EDITOR" ]]; then
        "$EDITOR" "${editor_args[@]}" "$file"
    elif command -v nano >/dev/null 2>&1; then
        nano "${editor_args[@]}" "$file"
    elif command -v vim >/dev/null 2>&1; then
        vim "${editor_args[@]}" "$file"
    else
        echo "âŒ No editor found. Set \$EDITOR or install nano or vim." >&2
        return 1
    fi
}

# --- Edit or view a remote file ---
edit_file() {
    local action="$1" # "edit" or "view".
    local remote_path="$2"
    shift 2
    local editor_args=("$@")

    # Resolve remote path.
    remote_path=$(ssh_exec "export $REMOTE_ENV; cd \"$current_dir\" && eval realpath \"$remote_path\"")

    local can_access=0
    local download_needed=0

    if ssh_exec "[[ -e \"$remote_path\" ]]"; then
        # Path exists, check if it's a file and is accessible.
        download_needed=1
        if ssh_exec "[[ -d \"$remote_path\" ]]"; then
            echo "ðŸŸ¡ Path is a directory." >&2
        elif ! ssh_exec "[[ -f \"$remote_path\" ]]"; then
            echo "ðŸŸ¡ Not a regular file." >&2
        elif ! ssh_exec "[[ -r \"$remote_path\" ]]"; then
            echo "ðŸš« File is not readable." >&2
        elif [[ "$action" == "edit" ]] && ! ssh_exec "[[ -w \"$remote_path\" ]]"; then
            read -rp "ðŸš« File is not writable. View it instead? [y] " >&2 response
            if [[ -z "$response" || "$response" =~ ^[yY]$ ]]; then
                can_access=1
                action="view"
            fi
        else
            can_access=1
        fi
    elif [[ "$action" == "edit" ]]; then
        # No existing file - check we can create it.
        local dirname=$(dirname "$remote_path")
        if ! ssh_exec "[[ -d \"$dirname\" ]]"; then
            echo "ðŸš« Directory not found." >&2
        elif ! ssh_exec "[[ -w \"$dirname\" ]]"; then
            echo "ðŸš« Directory is not writable." >&2
        else
            can_access=1
        fi
    else
        echo "ðŸš« File not found." >&2
    fi

    # Return now if we can't edit the requested file.
    (( can_access == 1 )) || return 1

    # Create a temporary file for local editing.
    local filename=$(basename "$remote_path")
    local local_file="$TEMP_DIR/$filename";

    # Download the file, if needed.
    if (( download_needed == 1 )); then
        if ! transfer_file "$USER@$HOST:$remote_path" "$local_file"; then
            echo "âŒ Failed to download file." >&2
            [[ -f "$local_file" ]] && rm "$local_file"
            return 1
        fi
        # Get checksum before editing.
        local sum_before=$(shasum "$local_file" | awk '{print $1}')
    fi

    # Run editor
    if launch_editor "$local_file" "${editor_args[@]}"; then
        # In edit mode, was a file either downloaded or created?
        if [[ "$action" == "edit" ]] && [[ -f $local_file ]]; then
            # Get new checksum.
            local sum_after=$(shasum "$local_file" | awk '{print $1}')
            # If the file has changed, upload it to remote.
            if [[ "$sum_after" != "$sum_before" ]]; then
                transfer_file "$local_file" "$USER@$HOST:$remote_path"
            else
                echo "ðŸŸ¡ File has not changed." >&2
            fi
        fi
    fi

    [[ -f "$local_file" ]] && rm "$local_file"
    return 0
}

# --- Resolve path as either local or remote ---
resolve_path() {
    local path="$1"

    if [[ "$path" == local:* ]]; then
        # Local path, strip prefix
        # Expand ~ and relative paths
        path="${path#local:}"
        echo "$(realpath -m "$path")"
    else
        # Remote path, prepend current_dir if relative
        [[ "$path" != /* ]] && path="${current_dir}/${path}"
        echo "${USER}@${HOST}:${path}"
    fi
}

# --- Handle the .rsync command ---
handle_rsync() {
    local -n cmd_args=$1
    local rsync_opts=()
    local paths=()

    # Split rsync options (leading '-') from paths
    for arg in "${cmd_args[@]}"; do
        if [[ "$arg" == -* && "${#paths[@]}" -eq 0 ]]; then
            rsync_opts+=("$arg")
        else
            paths+=("$arg")
        fi
    done

    # Resolve all paths (support local:)
    for i in "${!paths[@]}"; do
        paths[$i]=$(resolve_path "${paths[$i]}")
    done

    # Last argument is target
    local target="${paths[-1]}"
    unset 'paths[-1]'

    # Run rsync
    rsync -e "ssh $SSH_OPTIONS" "${rsync_opts[@]}" "${paths[@]}" "$target"
}

# --- Handle the .copy command ---
handle_copy() {
    local -n cmd_args=$1
    local args_with_opts=(-avP "${cmd_args[@]}")
    handle_rsync args_with_opts
}

# -------- Interactive operation --------

# First, check that we can connect successfully.
ssh_exec "exit" || exit $?
echo -e "\n$PANSSH_VERSION: Connected to $SITE_NAME.$ENV_ID\n" >&2

# Check for Bash version 4+.
if ! ( [[ $BASH_VERSION =~ ^([0-9]+)\. ]] && (( ${BASH_REMATCH[1]} >= 4 )) ) then
    echo -e "â„¹ï¸  Tab-completion in PanSSH requires Bash 4+\n" >&2
else
    # Find our readx script.
    readonly READX="readx.source.sh"
    READX_PATH="$SCRIPT_DIR/$READX"
    if [[ ! -f "$READX_PATH" ]]; then
        READX_PATH="$SCRIPT_DIR/../lib/panssh/$READX"
    fi

    if [[ ! -f "$READX_PATH" ]]; then
        echo -e "â„¹ï¸  Failed to find $READX. Tab-completion will not be available.\n" >&2
        unset READX_PATH
    else
        readonly READX_PATH
    fi
fi

# Get local colour settings.
readonly clr0=$(tput sgr0 2>/dev/null) \
&& readonly clr1=$(tput setaf 1 2>/dev/null) \
&& readonly clr2=$(tput setaf 3 2>/dev/null) \
&& readonly clr3=$(tput setaf 6 2>/dev/null)

# Escaped prompt used, with readx (bash command line input).
readonly prompt_ps1=$( printf \
    "\[${clr1}\]%s\[${clr0}\].\[${clr2}\]%s\[${clr0}\]:\[${clr3}\]%s\[${clr0}\]\$ " \
    "$SITE_NAME" "$ENV_ID" "_CWD_"
)

# Get un-escaped prompt, used with `echo` and `read`.
tmp=${prompt_ps1//\\[/}
readonly prompt=${tmp//\\]/}

# Set up command history behaviour.
export HISTFILE="$STORAGE_DIR/$SITE_NAME.$ENV_ID.history"
export HISTCONTROL=ignorespace:ignoredups:erasedups
history -r

# Set up initial state.
REMOTE_CWD="/code"
current_dir="$REMOTE_CWD"
current_status=0
auto_ls=0

# Basic environment checks.
if ssh_exec "cd $current_dir"; then
    if ssh_exec "[ -w $current_dir ]"; then
        echo -e "ðŸŸ¡ $current_dir directory is writable (SFTP mode)\n" >&2
    else
        echo -e "ðŸš« $current_dir directory is read-only (Git mode)\n" >&2
    fi
fi

# Create our remote home directory if it doesn't exist.
ssh_exec "mkdir -p \"$REMOTE_HOME\""

# --- Main loop ---
trap '' SIGINT
while true; do
    if [[ -n "$READX_PATH" ]]; then
        # readx is available - use it for command input.
        export READX_EXEC="ssh $SSH_OPTIONS $USER@$HOST 'echo %s | bash'"
        export REMOTE_ENV CWD="$current_dir"
        export READX_PROMPT="${prompt_ps1/_CWD_/$current_dir}"
        export READX_FIRST_TIME="${READX_FIRST_TIME:-1}"

        # Use bash interactive to read command input with completion.
        cmd=$(/usr/bin/env bash --init-file "$READX_PATH")
        # Re-display both prompt and input, to mimic standard Bash behaviour.
        echo "${prompt/_CWD_/$current_dir}$cmd"
        READX_FIRST_TIME=0
    else
        # readx is not available - use `read` for command input.
        cmd=$(
            trap - SIGINT
            bind '"\t":' 2>/dev/null
            read -e -r -p "${prompt/_CWD_/$current_dir}" cmd && echo $cmd
        ) || echo
        history -s "$cmd"
    fi

    # Handle empty input.
    [[ -z "$cmd" ]] && continue

    # Handle `exit [status]`.
    if [[ "$cmd" =~ ^exit([[:space:]]+(.*))?$ ]]; then
        current_status="${BASH_REMATCH[2]:-0}"
        break;
    fi

    # Handle built-in commands.
    if [[ "$cmd" =~ ^\.([[:alnum:]_]+)([[:space:]]+(.+))?$ ]]; then
        action="${BASH_REMATCH[1]}"

        # Get command arguments (if any).
        if [[ -n "${BASH_REMATCH[3]}" ]]; then
            read -ra args <<< "${BASH_REMATCH[3]}"
        else
            args=()  # no arguments
        fi

        case "$action" in
            help)
                show_commands
                continue
                ;;
            edit|ed)
                file_path="${args[0]}"
                edit_file "edit" "$file_path" "${args[@]:1}"
                continue
                ;;
            view|vw)
                file_path="${args[0]}"
                edit_file "view" "$file_path" "${args[@]:1}"
                continue
                ;;
            copy|cp)
                handle_copy args
                continue
                ;;
            rsync|rs)
                handle_rsync args
                continue
                ;;
        esac
    fi

    # Handle toggling of auto-ls feature.
    if [[ "$cmd" == ".ls" ]]; then
        if (( auto_ls == 0 )); then
            echo "âœ… Auto-ls enabled" >&2
            auto_ls=1
            ssh_exec "cd \"$current_dir\" && ls -pC --group-directories-first"
        else
            echo "ðŸš« Auto-ls disabled" >&2
            auto_ls=0
        fi
        continue
    fi

    # Execute a remote command:
    # Run the command with our environment, current directory and correct initial value for $?
    ssh_exec_track "export $REMOTE_ENV; cd \"$current_dir\" && bash -c \"exit $current_status\"" "$cmd"
    current_status=$?

    # Check whether the command changed the current directory.
    if [[ -n "$REMOTE_CWD"  &&  "$REMOTE_CWD" != "$current_dir" ]]; then
        current_dir="$REMOTE_CWD"

        # Automatic directory listing if enabled.
        if (( auto_ls == 1 )); then
            ssh_exec "cd \"$current_dir\" && ls -pC --group-directories-first"
        fi
    fi

done

exit $current_status
