#!/usr/bin/env bash

# CONFIGURATION
MAX_HISTORY_LINES=100

# INPUT PARAMETERS
SESSION_ID="$1"
PROMPT="$2"
PARTIAL_INPUT="$3"
FILE_DIR_LIST=$'.\n..\n'"$4"
OUTPUT_FILE="$5"

HISTFILE="$1"
IFS=$'\n'

# Build completion array from newline-separated input
IFS=$'\n' read -r -d '' -a COMPLETIONS < <(printf "%s\n" "$FILE_DIR_LIST" && printf '\0')
DIRS=($(for item in "${COMPLETIONS[@]}"; do [[ "$item" == */ ]] && echo "$item"; done))

# Initialize state
LINE="$PARTIAL_INPUT"
CURSOR=${#LINE}

# Terminal raw mode
stty -echo -icanon time 0 min 1

cleanup() {
  stty sane
  echo
}
trap cleanup EXIT

# Print prompt + input
printf "\r\033[K%s%s" "$PROMPT" "$LINE"

# Function to find longest common prefix
longest_common_prefix() {
  local prefix="$1"
  shift
  for word in "$@"; do
    while [[ "${word:0:${#prefix}}" != "$prefix" && -n "$prefix" ]]; do
      prefix="${prefix:0:$((${#prefix}-1))}"
    done
  done
  echo "$prefix"
}

# Load history
REAL_HISTORY=()
[[ -f "$HISTFILE" ]] && mapfile -t REAL_HISTORY < "$HISTFILE"

HISTORY=("${REAL_HISTORY[@]}" "$PARTIAL_INPUT")
HISTORY_INDEX=${#REAL_HISTORY[@]}  # â† start at last real entry, not partial input

output_and_exit() {
  local code=$1
  if [[ -n "$OUTPUT_FILE" ]]; then
    echo "$LINE" > "$OUTPUT_FILE"
  else
    echo "$LINE"
  fi
  echo "exit code: $code  line: $LINE"
  cat $OUTPUT_FILE
  exit "$code"
}


# Main input loop
while IFS= read -rsn1 char; do
  case "$char" in
    $'\e')  # Handle arrow keys (ESC sequence)
      read -rsn2 rest
      case "$rest" in
        '[A')  # Up arrow
          if (( HISTORY_INDEX > 0 )); then
            ((HISTORY_INDEX--))
            LINE="${HISTORY[HISTORY_INDEX]}"
            CURSOR=${#LINE}
            printf "\r\033[K%s%s" "$PROMPT" "$LINE"
          fi
          ;;
        '[B')  # Down arrow
          if (( HISTORY_INDEX < ${#HISTORY[@]} - 1 )); then
            ((HISTORY_INDEX++))
            LINE="${HISTORY[HISTORY_INDEX]}"
            CURSOR=${#LINE}
            printf "\r\033[K%s%s" "$PROMPT" "$LINE"
          fi
          ;;
      esac
      ;;
    '')  # ENTER
      echo
      LAST_HIST=""
      [[ -f "$HISTFILE" ]] && LAST_HIST=$(tail -n 1 "$HISTFILE")
      if [[ "$LINE" != "$LAST_HIST" ]]; then
        echo "$LINE" >> "$HISTFILE"
      fi

      tail -n "$MAX_HISTORY_LINES" "$HISTFILE" > "${HISTFILE}.tmp" && mv "${HISTFILE}.tmp" "$HISTFILE"
      output_and_exit 0
      ;;
    $'\t')  # TAB
      # Gather all completions that match the current input
      MATCHES=()
      for item in "${COMPLETIONS[@]}"; do
        [[ "$item" == "$LINE"* ]] && MATCHES+=("$item")
      done

      # Check for exact match to a directory and uniqueness
      exact_dir_match=""
      for dir in "${DIRS[@]}"; do
        if [[ "$LINE" == "$dir" || "$LINE" == "${dir%/}" ]]; then
          exact_dir_match="$dir"
          break
        fi
      done

      if [[ -n "$exact_dir_match" ]]; then
        if (( ${#MATCHES[@]} == 1 )); then
          echo
          # Return canonical form with slash if it was a directory
          for dir in "${DIRS[@]}"; do
            [[ "$LINE" == "${dir%/}" ]] && echo "$dir" && exit 0
          done
          output_and_exit 1
        fi
      fi

      if (( ${#MATCHES[@]} == 1 )); then
        LINE="${MATCHES[0]}"
        CURSOR=${#LINE}
        [[ ! "$LINE" == */ ]] && LINE="$LINE " && CURSOR=${#LINE}
        printf "\r\033[K%s%s" "$PROMPT" "$LINE"
      elif (( ${#MATCHES[@]} > 1 )); then
        COMMON=$(longest_common_prefix "${MATCHES[@]}")
        if [[ "$COMMON" != "$LINE" ]]; then
          LINE="$COMMON"
          CURSOR=${#LINE}
          printf "\r\033[K%s%s" "$PROMPT" "$LINE"
        else
          echo
          printf "%s\n" "${MATCHES[@]}" | paste -sd ' ' - | fold -s -w $(tput cols)
          printf "\r\033[K%s%s" "$PROMPT" "$LINE"
        fi
      fi
      ;;
    $'\177')  # BACKSPACE
      if (( CURSOR > 0 )); then
        removed_char="${LINE:$((CURSOR - 1)):1}"
        LINE="${LINE:0:$((CURSOR - 1))}${LINE:$CURSOR}"
        ((CURSOR--))

        printf "\r\033[K%s%s" "$PROMPT" "$LINE"

        # If we just removed a '/' and the new input no longer ends in '/'
        if [[ "$removed_char" == "/" && "$LINE" != */ ]]; then
          printf "\r\033[K%s\n" "$PROMPT$LINE"
          output_and_exit 1
        fi
      fi
      ;;
    *)  # Printable characters
      LINE="${LINE:0:$CURSOR}$char${LINE:$CURSOR}"
      ((CURSOR++))
      printf "\r\033[K%s%s" "$PROMPT" "$LINE"
      ;;
  esac
done
